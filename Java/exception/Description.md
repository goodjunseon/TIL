# 📌예외처리 구조
![예외 처리 구조](../img/exception-structure.png)
`Object` : 자바에서 기본형을 제외한 모든 것은 객체이다. 예외 또한 객체이다.\
모든 객체의 최상위 부모는 Object이므로 예외 객체 또한 최상위 부모는 Object이다.

`Throwable` : 최상위 예외이다. 하위에 Exception과 Error가 있다.

`Error` : 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구가 불가능한 시스템 예외이다.\
애플리케이션 개발자는 이 예외를 잡으려고 해서는 안된다[^1].
[^1]: Error는 JVM에서 발생하는 심각한 문제를 나타낸다.
일반적으로 메모리부족, 스택 오버플로우 같은 오류를 말한다.
따라서 이러한 오류는 애플리케이션 코드가 아닌, JVM 또는 시스템 자체에서 발생하는 문제라서
애플리케이션에서 복구할 방법이 없다.
추가로 Error를 catch해서 정상적으로 복구하려고 시도한다면, 실제로 프로그램이 심각한 오류 상태인데도 계속 실행되게 되므로, 예상치 못한 문제가 발생할 가능성이 크다.
애초에 Java의 예외처리 모델에서 Exception은 애플리케이션이 적적하게 처리할 수 있는 오류,
Error는 애플리케이션에서 제어할 수 없는 오류로 구분지어놨다.

`Exception` : 체크 예외
- 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외이다.
- `Exception`과 그 하위 예외는 모두 컴파일러가 체크하는 체크예외이다.\
단 `RuntimeException`은 예외로 한다.

`RuntimeException` : 언체크 예외, 런타임 예외  
- 컴파일러가 체크하지 않는 언체크 예외이다.
- `RuntimeException`과 그 자식 예외는 모두 언체크 예외이다.
- `RuntimeException`의 이름을 따라서 `RuntimeException`과 그 하위 언체크 예외를\
**런타임 예외**라고 많이 부른다.

# 📌체크 예외 vs 언체크 예외(런타임 예외)
체크 예외는 발생한 예외를 개발자가 명시적으로 처리해야한다. 그렇지 않으면 컴파일 오류가 발생한다.\
언체크 예외는 개발자가 발생한 예외를 명시적으로 처리하지 않아도 된다.\
- 체크 예외: 예외를 잡아서 처리하지 않으면 항상 `throws` 키워드를 사용해서 던지는 예외를 선언해야한다.
- 언체크 예외: 예외를 잡아서 처리하지 않아도 `throws` 키워드를 생략할 수 있다.

**주의해야할 점**/
상속 관계에서 부모 타입은 자식을 담을 수 있는데, 이것은 예외 처리에서도 적용된다.\
상위 예외를 `catch`로 잡으면그 하위 예외까지 함께 잡는다.\
따라서 애플리케이션 로직에서는 `Throwable` 예외를 잡으면 안된다.\
왜냐하면 `Error` 예외도 함께 잡을 수 있기 때문이다.\
애플리케이션 로직은 `Exception`부터 필요한 예외로 생각하고 잡으면 된다.

# 📌예외 기본 규칙
자바에서 예외는 다음과 같은 규칙만 기억하면 된다.
1. 예외는 잡아서 처리하거나 밖으로 던져야 한다.
2. 예외를 잡거나 던질 때 지정된 예외뿐만 아니라 그 예외의 자식들도 함께 처리할 수 있다.
   - 예를 들어, `Exception`을 `catch`로 잡으면 그 하위 예외들도 모두 잡을 수 있다.
   - 예를 들어, `Exception`을 `throws`로 던지면 그 하위 예외들도 모두 던질 수 있다.
     
**만약 예외를 처리하지 못하고 계속 던지게 된다면?**
자바에서 예외 로그를 출력하면서 시스템이 종료된다. 

# 📌체크 예외
체크 예외는 잡아서 처리하거나, 또는 밖으로 던지도록 **선언**해야한다. 그렇지 않으면 컴파일 오류가 발생한다.\
던지고 받는 과정에서 최상위 메서드에서 조차 처리가 되지 못할 땐, 예외 정보와 스택 트레이스(Stack Trace)를 출력하고 프로그램이 종료된다.\
1. 체크 예외를 밖으로 던지지 않으면 컴파일 오류가 발생한다.
2. 체크 예외를 밖으로 던질 때, 해당 타입과 그 하위 타입 모두 던질 수 있다.
3. 체크 예외는 개발자의 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 훌륭한 안전 장치이다.
4. 하지만 개발자가 모든 체크 예외를 반드시 잡거나 던지도록 처리해야하기 때문에, 번거롭다.

# 📌언체크 예외
RuntimeException과 그 하위 예제를 언체크 예외로 분류한다.\
언체크 예외는 컴파일러가 예외를 체크하지 않는다.\
언체크 예외는 체크 예외와 기본적으로 동일하지만, 예외를 던지는 `throws`를 선언하지 않고, 생략할 수 있다.\
생략할 경우 자동으로 예외를 던진다.\
언체크 예외도 `throws` 예외를 선언해도 된다. 물론 생략도 가능하다.\
언체크 예외는 주로 **생략**하지만, 중요한 예외의 경우 일부러 명시적으로 작성하기도 한다.\


